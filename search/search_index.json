{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About LTI What is LTI 1.3? It is a standard that empowers learning management platforms (LMS) to incorporate new functionalities. Managed by 1EdTech (Previously called IMS Global), this standard facilitates the transfer of data and content in a uniform and compatible manner between different educational systems. This interoperability is essential to ensure a consistent and seamless user experience, while encouraging innovation and expansion of the capabilities of digital educational platforms. LTI 1.3 is the core of the standard, there are also different services that allow extending the functionality, these are included within a package known as LTI Advantage. LTI Advantage This service is made up of different complements that seek to strengthen the LTI core, these are: Names and Role Provisioning Services (NRPS) Allows you to obtain the members of a course and their respective roles. If users are grouped, they will be returned in the respective groups. Deep Linking Allows you to add existing resources to the tool or build a resource from a previously defined configuration. Assignment and Grades Services (AGS) Allows you to create gradeable tasks and assign grades. The modification of notes is restricted to the scope of action of the LTI. LTI Platform Storage Allows a tool to store temporary values within a window initialized by a platform. This definition seeks to solve the problem of third-party cookies. Going deeper into the standards STANDARD URL LTI 1.3 Go to standard Deep Linking Go to standard NRSP Go to standard AGS Go to standard LTI Platform Storage Go to standard LTI Advantage Go to standard Currently this package only has support for the LTI 1.3 core and LTI Deep Linking . In the development branch there is a proof of concept to consume other LTI Advantage services, that works in Moodle but we have encountered difficulties for canvas, once resolved we will support it in a more standardized way.","title":"About LTI"},{"location":"#about-lti","text":"","title":"About LTI"},{"location":"#what-is-lti-13","text":"It is a standard that empowers learning management platforms (LMS) to incorporate new functionalities. Managed by 1EdTech (Previously called IMS Global), this standard facilitates the transfer of data and content in a uniform and compatible manner between different educational systems. This interoperability is essential to ensure a consistent and seamless user experience, while encouraging innovation and expansion of the capabilities of digital educational platforms. LTI 1.3 is the core of the standard, there are also different services that allow extending the functionality, these are included within a package known as LTI Advantage.","title":"What is LTI 1.3?"},{"location":"#lti-advantage","text":"This service is made up of different complements that seek to strengthen the LTI core, these are: Names and Role Provisioning Services (NRPS) Allows you to obtain the members of a course and their respective roles. If users are grouped, they will be returned in the respective groups. Deep Linking Allows you to add existing resources to the tool or build a resource from a previously defined configuration. Assignment and Grades Services (AGS) Allows you to create gradeable tasks and assign grades. The modification of notes is restricted to the scope of action of the LTI. LTI Platform Storage Allows a tool to store temporary values within a window initialized by a platform. This definition seeks to solve the problem of third-party cookies.","title":"LTI Advantage"},{"location":"#going-deeper-into-the-standards","text":"STANDARD URL LTI 1.3 Go to standard Deep Linking Go to standard NRSP Go to standard AGS Go to standard LTI Platform Storage Go to standard LTI Advantage Go to standard Currently this package only has support for the LTI 1.3 core and LTI Deep Linking . In the development branch there is a proof of concept to consume other LTI Advantage services, that works in Moodle but we have encountered difficulties for canvas, once resolved we will support it in a more standardized way.","title":"Going deeper into the standards"},{"location":"changelog/","text":"Changelog Version 6.0.2 1.- General remember token returns from the dead Version 6.0.1 1.- General Update dependencies and their impact to migrate to PHP-JWT >6.0 and fix the security gap Update outdated model imports without the \"Lti\" prefix to load Models from the \"App\" namespace instead of the package. Change the signature of the methods in the LtiRolesManager trait to receive LtiContext instead of Context. Same for LtiUserRole. Remove unnecessary columns from the model and lti user migrations (password, remembertoken). Version 6.0.0 1.- General Unused use statements are removed The seeders that created an administrator user are removed, now the package does not use seeders. 2.- Migrations Add prefix in migrations for tables and attributes with lti1p3_ to avoid name collisions All migrations use anonymous classes The creation source columns are eliminated (LTI - MANUAL) now everything stored is purely LTI. Previously the package took over the users table and that column made the difference in the creation source, now lti users are stored in their own users table with the prefix lti1p3_. 3.- Models Models are prefixed with \"Lti\" to avoid name collisions The \"isToolAdmin\" method is eliminated in the user model since access to the dashboard is now with global credentials. 4.- Instances Soft delete is added Since find and findOrFail can be perfectly used to search for an instance with the identifier, \"RecoveryFromId()\" is eliminated and, failing that, the relationships loaded by said method (platform, context, resource_link, user) are loaded by default in the model declaration 5.- Non-lti authentication In previous versions, the package took over the concept of users and managed both those created through LTI and those that could be created manually in any other context of the application. Subsequently, resources such as the Auth facade were used to implement a login that allowed access to the LMS registration panel. This approach was incorrect as it restricted the functionality of mixed users (LTI and non-LTI). Additionally, building a custom login required overriding some functionality that the package was hijacking by managing users in a standard way. Currently, we are looking to disassociate LTI users from the actions you want to perform in your application. For this reason, administration of the LTI panel will be carried out using a global user and password defined in its environment file and the lti users will be stored in a different table. 6.- Routes Routes and their names are prefixed with lti1p3 The redirection of the login route to LTI authentication is eliminated Dashboard access is now: {YOUR_DOMAIN}/lti1p3/login 6.- Middleware The old \"lti_instance_recovery\" is renamed to \"inject_lti_instance\" A new middleware \"lti1p3_session\" is added to check if the user is logged in as the LTI administrator 7.- Validation of initial content in the LTI protocol The user parameters: name, given_name, family_name and lis can be null, since the LTI can be configured to pass user data anonymously and that data is not sent, in previous versions of the package they are being required, which is why , when that configuration was given the LTI did not start throwing an exception. 8.- Vistas - Migration from Material design bootstrap to Bootstrap 5.3.x - Redesign of the administration panel for platforms - Ability to edit a platform without having to delete it to recreate it Version 5.1.0 1.- Now the user is authenticated with the middleware lti_instance_recovery Having the user data in the instance is important, but it wasn't enough to work with policies and gates. Now, the middleware will also take care of authenticating the user automatically. Version 5.0.1 1.- Fix input name when renderize the instance id with the blade directive The blade directive renders a hidden input for you which is then retrieved by the middleware using a specific identifier. After the previous update, we forgot to update the key name for this directive. Version 5.0.0 1.- Standardize the http code of responses when use lti_instance_recovery middleware In previous versions, passing an incorrect instance could generate 404 responses instead of 401 (unauthorized) among other security problems. Now if the token is not valid you will always get a 401 which is easier for the client to control. 2.- Standardize instance key for lti_instance_recovery middleware In older versions you could pass an instance identifier in the headers or as part of the request. These identifiers were similar but not the same, now for both cases the key is the same. // key name before (HEADERS): lti1p3-instance-id // key name before (REQUEST) lti1p3_instance_id // key name now, for both cases (HEADERS - REQUEST) lti1p3-instance-id Version 4.1.0 1.- Add leeway for check if token content is expired Sometimes a lag of seconds could lead to a token expiration just because a request took longer than usual, that doesn't mean the token is actually expired. A maneuver time has been included by default to check if the token is expired or not (240s). Version 4.0.1 1.- Fix publishing path for views and translations The published views and translations do not overwrite the package files, this was because the call and publish paths were different. Version 4.0.0 1.- Instances have expiration time You may want to use the instances that contain all the necessary context and user information as an authentication token, considering that only one UUID is valid for the client and you have all the information in your backend. In practice, it is not necessary to use the instances and a different authentication system, because the instance will only be created when the LTI launch is correct, in other words, the LMS is in charge of verifying that the user is real. Now, in the package configuration there is a new key that allows to define null or a number of seconds to determine the durability of the instance, after that, the application will return a 401 to all the routes that it protected with the lti_instance_recovery middleware. Version 3.1.1 1.- Prefixed resources You may want to have your own style.css file and forget about package styles. Now our style.css is called lti1p3_style.css to avoid potential collisions. Other unused css files were removed. Version 3.1.0 1.- New functions for get custom vars passed from LMS In the content class, in charge of accessing the initial JWT message in a more friendly way, you will now have methods that will allow you to access and check custom variables established in the LTI configuration within the LMS. public function getAllCustomVars() : ?object public function getCustomVar(string $name) : mixed public function hasCustomVar(string $name) : bool public function getCustomVarOrFail(string $name) : mixed The method names are self-descriptive, just keep in mind that the failure for getCustomVarOrFail is an Exception. 2.- Remove optional functions These functions don't really make much sense, they returned null when a variable didn't exist and you had to check that later. We focus on what is important and leave the control of the optionality to you with the syntax of php 8. // Removed functions in content class. public function optionalResourceLinkAttribute(string $attribute) : mixed public function optionalPlatformAttribute(string $attribute) : mixed Now you can do something like this: // reference $content->getPlatform()->some_optional_var ?? whatever; // Example of actual usage $validation_context = $content->getPlatform()->validation_context ?? null; Version 3.0.2 1.- Remove unused importation Removed an unused import in the launch controller. The import could be confusing and imported the Instance model directly from the package instead of the published model. Version 3.0.1 1.- Fix roles Since the current user is no longer authenticated and the way roles are stored was reformulated, the roles trait was corrupted. Now methods that query for roles require a context instance to query for roles in a particular context. 2.- Fix models importation Some model imports kept referencing the original models in the package and not the ones published within your application. If you wanted to add methods or new things in general they would never work because in reality the published model was not the one that was being called. Another issue identified was that passing an instance of a model could fail due to the model having a different namespace. Version 3.0.0 1.- Deep linking support. Support for deep link launches is added. This generates changes in the LTI launch methods (See point 2). A new class is implemented to generate responses of type Deep Linking and can be found at: xcesaralejandro\\lti1p3\\Classes\\DeepLinkingResponse . 2.- Goodbye to the launch method onLaunch() Previously you only had to worry about starting your application in the onLaunch() method, there the initial message was already signed and the message type was ignored and treated as a resource hook due to lack of support. for Deep Linking . The method is now renamed based on the initial message type based on the standard. onLaunch() is now called onResourceLinkRequest() and onDeepLinkingRequest() is added. If your application doesn't use Deep Linking , handling the launch in onResourceLinkRequest() should suffice. 3.- Hello launch ids Since sessions were easily lost or overwritten when launching the same LTI in multiple browser tabs, maintaining LTI launch data was a problem. Now items related to the LTI release are stored in the database under an identifier that will allow the information to be retrieved later, the identifier must be passed constantly between URL changes. 4.- Aids for handling identifiers Constantly passing the identifier between URLs and then retrieving the data is somewhat tedious, so a middleware called lti_instance_recovery appears that will verify the existence of a parameter called lti1p3_instance_id inside the Request , if it exists, will retrieve the instance and include it within the same Request . You can also use Instance::RecoveryFromId($ID) to retrieve data from an instance manually. Passing the instance identifier to the view shouldn't be a problem, but if we have a lot of forms creating inputs hidden can be inelegant. Failing that, use the @addinstance($instance_id) directive which will add an input hidden for you. Version 2.0.0 1.- Corrects the implementation of \"deployments\". Previously, the deployment was linked to the platform registry, this limited the lti to be installed only once within the LMS (what a mistake...). Now the deployment record was separated into its own table -as specified by the standard- and with this it is possible to install the LTI globally, in specific courses or as you wish. The admin panel has been updated to support this change. 2.- User roles are now stored locally Role validations are still performed at runtime, but now the roles are being stored in a table for record keeping (These can become out of date if a role is updated in the LMS and the user does not log back into the LTI) . It is possible that roles from higher contexts are repeated, since they transcend to a lower level context and currently all the roles passed by the LMS are saved, associating them with their launch context. Roles were split into a new table and removed as a column from users. 3.- Goodbye deleted records Soft deletes have been implemented for all models. 4.- Nod to LTI Advantage Added a new field for platform registration: lti_advantage_token_url this allows defining an endpoint to obtain lti advantage tokens. Even though it's not implemented yet, it puts pressure on me and reminds me to keep developing.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#version-602","text":"1.- General remember token returns from the dead","title":"Version 6.0.2"},{"location":"changelog/#version-601","text":"1.- General Update dependencies and their impact to migrate to PHP-JWT >6.0 and fix the security gap Update outdated model imports without the \"Lti\" prefix to load Models from the \"App\" namespace instead of the package. Change the signature of the methods in the LtiRolesManager trait to receive LtiContext instead of Context. Same for LtiUserRole. Remove unnecessary columns from the model and lti user migrations (password, remembertoken).","title":"Version 6.0.1"},{"location":"changelog/#version-600","text":"1.- General Unused use statements are removed The seeders that created an administrator user are removed, now the package does not use seeders. 2.- Migrations Add prefix in migrations for tables and attributes with lti1p3_ to avoid name collisions All migrations use anonymous classes The creation source columns are eliminated (LTI - MANUAL) now everything stored is purely LTI. Previously the package took over the users table and that column made the difference in the creation source, now lti users are stored in their own users table with the prefix lti1p3_. 3.- Models Models are prefixed with \"Lti\" to avoid name collisions The \"isToolAdmin\" method is eliminated in the user model since access to the dashboard is now with global credentials. 4.- Instances Soft delete is added Since find and findOrFail can be perfectly used to search for an instance with the identifier, \"RecoveryFromId()\" is eliminated and, failing that, the relationships loaded by said method (platform, context, resource_link, user) are loaded by default in the model declaration 5.- Non-lti authentication In previous versions, the package took over the concept of users and managed both those created through LTI and those that could be created manually in any other context of the application. Subsequently, resources such as the Auth facade were used to implement a login that allowed access to the LMS registration panel. This approach was incorrect as it restricted the functionality of mixed users (LTI and non-LTI). Additionally, building a custom login required overriding some functionality that the package was hijacking by managing users in a standard way. Currently, we are looking to disassociate LTI users from the actions you want to perform in your application. For this reason, administration of the LTI panel will be carried out using a global user and password defined in its environment file and the lti users will be stored in a different table. 6.- Routes Routes and their names are prefixed with lti1p3 The redirection of the login route to LTI authentication is eliminated Dashboard access is now: {YOUR_DOMAIN}/lti1p3/login 6.- Middleware The old \"lti_instance_recovery\" is renamed to \"inject_lti_instance\" A new middleware \"lti1p3_session\" is added to check if the user is logged in as the LTI administrator 7.- Validation of initial content in the LTI protocol The user parameters: name, given_name, family_name and lis can be null, since the LTI can be configured to pass user data anonymously and that data is not sent, in previous versions of the package they are being required, which is why , when that configuration was given the LTI did not start throwing an exception. 8.- Vistas - Migration from Material design bootstrap to Bootstrap 5.3.x - Redesign of the administration panel for platforms - Ability to edit a platform without having to delete it to recreate it","title":"Version 6.0.0"},{"location":"changelog/#version-510","text":"1.- Now the user is authenticated with the middleware lti_instance_recovery Having the user data in the instance is important, but it wasn't enough to work with policies and gates. Now, the middleware will also take care of authenticating the user automatically.","title":"Version 5.1.0"},{"location":"changelog/#version-501","text":"1.- Fix input name when renderize the instance id with the blade directive The blade directive renders a hidden input for you which is then retrieved by the middleware using a specific identifier. After the previous update, we forgot to update the key name for this directive.","title":"Version 5.0.1"},{"location":"changelog/#version-500","text":"1.- Standardize the http code of responses when use lti_instance_recovery middleware In previous versions, passing an incorrect instance could generate 404 responses instead of 401 (unauthorized) among other security problems. Now if the token is not valid you will always get a 401 which is easier for the client to control. 2.- Standardize instance key for lti_instance_recovery middleware In older versions you could pass an instance identifier in the headers or as part of the request. These identifiers were similar but not the same, now for both cases the key is the same. // key name before (HEADERS): lti1p3-instance-id // key name before (REQUEST) lti1p3_instance_id // key name now, for both cases (HEADERS - REQUEST) lti1p3-instance-id","title":"Version 5.0.0"},{"location":"changelog/#version-410","text":"1.- Add leeway for check if token content is expired Sometimes a lag of seconds could lead to a token expiration just because a request took longer than usual, that doesn't mean the token is actually expired. A maneuver time has been included by default to check if the token is expired or not (240s).","title":"Version 4.1.0"},{"location":"changelog/#version-401","text":"1.- Fix publishing path for views and translations The published views and translations do not overwrite the package files, this was because the call and publish paths were different.","title":"Version 4.0.1"},{"location":"changelog/#version-400","text":"1.- Instances have expiration time You may want to use the instances that contain all the necessary context and user information as an authentication token, considering that only one UUID is valid for the client and you have all the information in your backend. In practice, it is not necessary to use the instances and a different authentication system, because the instance will only be created when the LTI launch is correct, in other words, the LMS is in charge of verifying that the user is real. Now, in the package configuration there is a new key that allows to define null or a number of seconds to determine the durability of the instance, after that, the application will return a 401 to all the routes that it protected with the lti_instance_recovery middleware.","title":"Version 4.0.0"},{"location":"changelog/#version-311","text":"1.- Prefixed resources You may want to have your own style.css file and forget about package styles. Now our style.css is called lti1p3_style.css to avoid potential collisions. Other unused css files were removed.","title":"Version 3.1.1"},{"location":"changelog/#version-310","text":"1.- New functions for get custom vars passed from LMS In the content class, in charge of accessing the initial JWT message in a more friendly way, you will now have methods that will allow you to access and check custom variables established in the LTI configuration within the LMS. public function getAllCustomVars() : ?object public function getCustomVar(string $name) : mixed public function hasCustomVar(string $name) : bool public function getCustomVarOrFail(string $name) : mixed The method names are self-descriptive, just keep in mind that the failure for getCustomVarOrFail is an Exception. 2.- Remove optional functions These functions don't really make much sense, they returned null when a variable didn't exist and you had to check that later. We focus on what is important and leave the control of the optionality to you with the syntax of php 8. // Removed functions in content class. public function optionalResourceLinkAttribute(string $attribute) : mixed public function optionalPlatformAttribute(string $attribute) : mixed Now you can do something like this: // reference $content->getPlatform()->some_optional_var ?? whatever; // Example of actual usage $validation_context = $content->getPlatform()->validation_context ?? null;","title":"Version 3.1.0"},{"location":"changelog/#version-302","text":"1.- Remove unused importation Removed an unused import in the launch controller. The import could be confusing and imported the Instance model directly from the package instead of the published model.","title":"Version 3.0.2"},{"location":"changelog/#version-301","text":"1.- Fix roles Since the current user is no longer authenticated and the way roles are stored was reformulated, the roles trait was corrupted. Now methods that query for roles require a context instance to query for roles in a particular context. 2.- Fix models importation Some model imports kept referencing the original models in the package and not the ones published within your application. If you wanted to add methods or new things in general they would never work because in reality the published model was not the one that was being called. Another issue identified was that passing an instance of a model could fail due to the model having a different namespace.","title":"Version 3.0.1"},{"location":"changelog/#version-300","text":"1.- Deep linking support. Support for deep link launches is added. This generates changes in the LTI launch methods (See point 2). A new class is implemented to generate responses of type Deep Linking and can be found at: xcesaralejandro\\lti1p3\\Classes\\DeepLinkingResponse . 2.- Goodbye to the launch method onLaunch() Previously you only had to worry about starting your application in the onLaunch() method, there the initial message was already signed and the message type was ignored and treated as a resource hook due to lack of support. for Deep Linking . The method is now renamed based on the initial message type based on the standard. onLaunch() is now called onResourceLinkRequest() and onDeepLinkingRequest() is added. If your application doesn't use Deep Linking , handling the launch in onResourceLinkRequest() should suffice. 3.- Hello launch ids Since sessions were easily lost or overwritten when launching the same LTI in multiple browser tabs, maintaining LTI launch data was a problem. Now items related to the LTI release are stored in the database under an identifier that will allow the information to be retrieved later, the identifier must be passed constantly between URL changes. 4.- Aids for handling identifiers Constantly passing the identifier between URLs and then retrieving the data is somewhat tedious, so a middleware called lti_instance_recovery appears that will verify the existence of a parameter called lti1p3_instance_id inside the Request , if it exists, will retrieve the instance and include it within the same Request . You can also use Instance::RecoveryFromId($ID) to retrieve data from an instance manually. Passing the instance identifier to the view shouldn't be a problem, but if we have a lot of forms creating inputs hidden can be inelegant. Failing that, use the @addinstance($instance_id) directive which will add an input hidden for you.","title":"Version 3.0.0"},{"location":"changelog/#version-200","text":"1.- Corrects the implementation of \"deployments\". Previously, the deployment was linked to the platform registry, this limited the lti to be installed only once within the LMS (what a mistake...). Now the deployment record was separated into its own table -as specified by the standard- and with this it is possible to install the LTI globally, in specific courses or as you wish. The admin panel has been updated to support this change. 2.- User roles are now stored locally Role validations are still performed at runtime, but now the roles are being stored in a table for record keeping (These can become out of date if a role is updated in the LMS and the user does not log back into the LTI) . It is possible that roles from higher contexts are repeated, since they transcend to a lower level context and currently all the roles passed by the LMS are saved, associating them with their launch context. Roles were split into a new table and removed as a column from users. 3.- Goodbye deleted records Soft deletes have been implemented for all models. 4.- Nod to LTI Advantage Added a new field for platform registration: lti_advantage_token_url this allows defining an endpoint to obtain lti advantage tokens. Even though it's not implemented yet, it puts pressure on me and reminds me to keep developing.","title":"Version 2.0.0"},{"location":"develop/","text":"Time to develop Entry point The application will publish models and controller, you can start developing from there. After registering a platform (LMS), the package will be in charge of synchronizing and updating all the data coming from the LMS or creating it if it does not exist. With this data we refer to the information of the platform, course, resource, user, etc. Once the launch has concluded, the LtiController is called in its different methods depending on the final state of the flow. <?php namespace App\\Http\\Controllers; use xcesaralejandro\\lti1p3\\Http\\Controllers\\Lti1p3Controller; class LtiController extends Lti1p3Controller { /* Important! Consider that an LTI can be added on multiple sides, sometimes your LTI can receive LtiResourceLinkRequest and LtiDeepLinkingRequest triggers */ public function onResourceLinkRequest(string $instance_id) : mixed { return parent::onResourceLinkRequest($instance_id); // Do something, here it is not necessary to call the parent function, // it is only to maintain the example functionality // This method is called when the lti launch is of type LtiResourceLinkRequest // You can read about it here: http://www.imsglobal.org/spec/lti/v1p3/#resource-link-launch-request-message // In human words, it is the launch of the LTI after doing the validations behind the scenes and the synchronization // of the data that arrives from the LMS with the local platform (The one that you must now start developing). // Sometimes this launch can be skipped by a custom redirect if you defined it in the LMS or it is a LtiDeepLinkingRequest. } public function onDeepLinkingRequest(string $instance_id) : mixed { return parent::onDeepLinkingRequest($instance_id); // Do something, here it is not necessary to call the parent function, // it is only to maintain the example functionality // This method is called when the lti launch is of type LtiDeepLinkingRequest // You can read about it here: https://www.imsglobal.org/spec/lti-dl/v2p0#overview // In human words, it is the launch of the LTI when it comes to DeepLinking. This, depending on the location where you add your LTI, // allows you to generate custom resources, return tasks, among other things. // I recommend reading the specification because to date I haven't tested everything it allows (UPS!). // In such a launch you must reply back to the LMS with a DeepLinking message to end the cycle. // You can browse the original model to review how the example works. } public function onError(mixed $exception = null) : mixed { return parent::onError($exception); // Do something, here it is not necessary to call the parent function, // it is only to maintain the example functionality // The onError method will be thrown when an invalid connection is attempted, // something goes wrong in the launch process (LMS-LTI). If it is the latter case, // it is most likely due to some problem with the configuration. // If you're sure you've set everything up correctly and you're still getting errors, // open a github bug, I'll be happy to cry with you for not understanding what's wrong. } } At launch you will receive an instance that will allow you to have all the information regarding the launch. The methods of this controller are also a good point to consult extra information such as custom variables. Once you have reached this point and have made sure that you have all the necessary values, you can redirect to another controller or even another domain, passing the data in the way that best suits you, from there you can build an application as you like. knows how to do it. Understanding the instance_id What the heck is the instance id? LTIs are loaded in iframes, which means that all cookies are considered third-party and, based on new browser policies, are blocked. This problem manifests itself especially in the context of sessions, since the session identifier, stored in a cookie on the client side by the server, would not persist. Additionally, the package is designed to address various needs that may arise with an LTI, such as a resource in a virtual classroom. If a course has two or more LTI resources, and they are opened independently one after another, the session would be overwritten. A possible solution would be to manage a session and store data according to the open tab, although this modifies the traditional concept of a session and can lead to errors at runtime. Although we have found other details in the process, these two elements were decisive in choosing to create an instance. After various trials and errors, we sought a friendly implementation. The instance includes everything necessary to access what is provided by the LTI, while offering elements to use it as an obfuscated security token (UUID). Instances are generated upon launch; That is, if a person opens the LTI in two different tabs, he will have two different instances. If the person reloads the page while in a browser tab, a new instance will be created. This instance-as-identifier approach is very useful in the context of backend for frontend (BFF), webservices, or other concepts that require an authentication token. To use Laravel as a server-side renderer (SSR) and still use Laravel as usual (possibly with Blade), you can add and retrieve the instance identifier in your forms using the controller. Also note the existence of middlewares and the Blade directive, which will make it easier to pass and obtain the instance ID when working in SSR mode. Retrieve an instance from the handle use App\\Models\\LtiInstance; $instance = LtiInstance::find($instance_id); If you are working with SSR you will have to constantly share your instance identifier between the different forms, you can use the following blade helper to add your instance, this will create an entry with a name defined by the package and then recover the instances with a middleware. @addinstance($instance_id) If you add the instance middleware, it will attempt to retrieve a key called lti1p3-instance-id from the request headers or parameters and initialize the model to include it in your request. inject_lti_instance At this point, you can add the middleware globally and rely on the blade directive to render the identifier of your instance. Current user roles Before starting with the functions that the package provides, it is necessary to understand the roles that exist in the vocabulary defined in the LTI 1.3 standard. See role vocabularies If we look at the role tables, these are made up of four scopes: system, institution, membership and person (Although the latter are deprecated, they can still exist). Below, in the point \"A.2.3.1 Context sub-roles\" a grouping of roles is shown without deepening the scope, with a logic of main role and sub-roles, from there the package is based to make some functions available that will allow you to check the role of a user. Eventually the roles of a user can vary depending on the context, while others are general. The package is transparent and on each launch it will store all the roles passed by the LMS and associate them to the context where the LTI is being launched, even if it is a higher context role. Note that there may be a mismatch between the current roles in the LMS and those stored in the LTI. If a user does not launch the LTI, it has no way of knowing the user's current roles. Therefore, if a user does not re-enter the LTI anymore and their roles change, there will be a lag for the roles that are stored. Roles will always be updated for the user in the LTI when it is launched and you can use LTI Advantage Names and Roles Service (NRPS) for update the roles without depend of user access. Behind the scenes, user roles are managed by a different model than user, eventually you will be able to bring in all the roles of a user or work with eloquent as usual. If you are working in a particular context, you will need the roles of that context, so these thoughtful methods for managing LTI roles will help make your life easier. Once you query the roles of a context, the model will keep them inside an array in the respective class instance to avoid multiple queries, since the roles should change (update) only on LTI launch. With this in mind, we describe methods that will help you manipulate roles. The $user variable is an instance of the LtiUser model. The $context variable is a reference to the LtiContext model. $user->isAdmin($context) $user->isContentDeveloper($context) $user->isInstructor($context) $user->isLearner($context) $user->isManager($context) $user->isMentor($context) $user->isOfficer($context) $user->isMember($context) $user->isTestUser($context) By default, the above functions will search for sub-roles in all scopes (system, institution, membership and person), the sub-roles for each \"Main Role\" are defined as an array within the package configuration file, for which, you can modify them from there in case you need it. The user class has a trait that takes care of the roles and has some static properties that will serve to pass as a scope filter to the previous functions. public static $SYSTEM_ROLES = 'http://purl.imsglobal.org/vocab/lis/v2/system/person#'; public static $INSTITUTIONAL_ROLES = 'http://purl.imsglobal.org/vocab/lis/v2/institution/person#'; public static $CONTEX_ROLES = 'http://purl.imsglobal.org/vocab/lis/v2/membership#'; public static $PERSON_ROLES = 'http://purl.imsglobal.org/vocab/lti/system/person#'; Then, you can query for a main role in a particular scope as follows: use App\\Models\\LtiUser; $user->isAdmin($context, LtiUser::$CONTEX_ROLES) user->isContentDeveloper($context, LtiUser::$CONTEX_ROLES) $user->isInstructor($context, LtiUser::$CONTEX_ROLES) $user->isLearner($context, LtiUser::$CONTEX_ROLES) $user->isManager($context, LtiUser::$CONTEX_ROLES) $user->isMentor($context, LtiUser::$CONTEX_ROLES) $user->isOfficer($context, LtiUser::$CONTEX_ROLES) $user->isMember($context, LtiUser::$CONTEX_ROLES) $user->isTestUser($context, LtiUser::$CONTEX_ROLES) Now we will list some functions that may be useful to you. \"Friendly role\": It is the role without the specification prefix Returns the roles in a friendly and unique way, this means that if the role is repeated in different scopes, it will only be shown once. $user->getAllRoles($context) Returns the system roles in a friendly way $user->getSystemRoles($context) Returns institutional roles in a friendly way $user->getInstitutionRoles($context) Returns context roles in a friendly way $user->getContextRoles($context) Return person roles in a friendly way $user->getPersonRoles($context) It receives an array of roles and a context (understand context as the static variables that contain the scope). Returns a boolean in case of having any of the roles, if a context is not passed it will be searched in all contexts. $user->hasSomeRolesOf(Context $context, array $role_list, ?string $role_context=null) Example It will look for the roles in all scopes and returns true if it finds any $user->hasSomeRolesOf($context, ['Administrator', 'Instructor']) It will look for the roles in the context scope and return true if it finds any $user->hasSomeRolesOf($context, ['Administrator', 'Instructor'], LtiUser::$CONTEX_ROLES) It receives a role name and a context (understand context as the static variables that contain the scope). Returns a bolean in case of having the role, if a context is not passed it will be searched in all contexts. $user->hasRole(Context $context, string $role_name , ?string $role_context = null) Example Will look for the role in all scopes $user->hasRole($context, 'Administrator') Will look for the role in the person scope $user->hasRole($context, 'Administrator', LtiUser::$CONTEX_ROLES) Get data from initial message The LTI launch data is contained in a JWT sent as an initial message. This message can be retrieved from the instance managed by the package. The package uses some classes that you can call to work with the initial message and retrieve some more \"raw\" information. use App\\Models\\LtiInstance; use xcesaralejandro\\lti1p3\\Classes\\Content; use xcesaralejandro\\lti1p3\\Classes\\Message; public function onResourceLinkRequest(string $instance_id) : mixed { $instance = LtiInstance::findOrFail($instance_id); $content = Message::decodeJWT($instance->platform, $instance->initial_message); // Get custom vars $some_var_1 = $content->getCustomVar('VAR_DEFINED_IN_THE_LMS'); $some_var_2 = $content->getCustomVarOrFail('VAR_DEFINED_IN_THE_LMS'); // Recovery initial message $raw_message = $content->getRawJwt(); // Redirect to your app logic return (new LaunchController)->appStart($instance_id); } As seen in the previous example, we recover the instance and from the Message class we decode the initial message, then we access some methods that will allow us to obtain personalized variables in a better way and another method that allows us to obtain the initial message with all the information already decoded . Finally we redirect to another point in our application. To learn more methods you can review the public methods in the Content class. Many times you will only need custom variables, since the rest of the values are taken care of by the package in the respective published models. Middlewares Name Description lti1p3_session Check if the user is logged in as the LTI administrator inject_lti_instance Adds an LtiInstance instance to the request when a key lti1p3-instance-id exists in the headers or parameters of the request.","title":"Time to develop"},{"location":"develop/#time-to-develop","text":"","title":"Time to develop"},{"location":"develop/#entry-point","text":"The application will publish models and controller, you can start developing from there. After registering a platform (LMS), the package will be in charge of synchronizing and updating all the data coming from the LMS or creating it if it does not exist. With this data we refer to the information of the platform, course, resource, user, etc. Once the launch has concluded, the LtiController is called in its different methods depending on the final state of the flow. <?php namespace App\\Http\\Controllers; use xcesaralejandro\\lti1p3\\Http\\Controllers\\Lti1p3Controller; class LtiController extends Lti1p3Controller { /* Important! Consider that an LTI can be added on multiple sides, sometimes your LTI can receive LtiResourceLinkRequest and LtiDeepLinkingRequest triggers */ public function onResourceLinkRequest(string $instance_id) : mixed { return parent::onResourceLinkRequest($instance_id); // Do something, here it is not necessary to call the parent function, // it is only to maintain the example functionality // This method is called when the lti launch is of type LtiResourceLinkRequest // You can read about it here: http://www.imsglobal.org/spec/lti/v1p3/#resource-link-launch-request-message // In human words, it is the launch of the LTI after doing the validations behind the scenes and the synchronization // of the data that arrives from the LMS with the local platform (The one that you must now start developing). // Sometimes this launch can be skipped by a custom redirect if you defined it in the LMS or it is a LtiDeepLinkingRequest. } public function onDeepLinkingRequest(string $instance_id) : mixed { return parent::onDeepLinkingRequest($instance_id); // Do something, here it is not necessary to call the parent function, // it is only to maintain the example functionality // This method is called when the lti launch is of type LtiDeepLinkingRequest // You can read about it here: https://www.imsglobal.org/spec/lti-dl/v2p0#overview // In human words, it is the launch of the LTI when it comes to DeepLinking. This, depending on the location where you add your LTI, // allows you to generate custom resources, return tasks, among other things. // I recommend reading the specification because to date I haven't tested everything it allows (UPS!). // In such a launch you must reply back to the LMS with a DeepLinking message to end the cycle. // You can browse the original model to review how the example works. } public function onError(mixed $exception = null) : mixed { return parent::onError($exception); // Do something, here it is not necessary to call the parent function, // it is only to maintain the example functionality // The onError method will be thrown when an invalid connection is attempted, // something goes wrong in the launch process (LMS-LTI). If it is the latter case, // it is most likely due to some problem with the configuration. // If you're sure you've set everything up correctly and you're still getting errors, // open a github bug, I'll be happy to cry with you for not understanding what's wrong. } } At launch you will receive an instance that will allow you to have all the information regarding the launch. The methods of this controller are also a good point to consult extra information such as custom variables. Once you have reached this point and have made sure that you have all the necessary values, you can redirect to another controller or even another domain, passing the data in the way that best suits you, from there you can build an application as you like. knows how to do it.","title":"Entry point"},{"location":"develop/#understanding-the-instance_id","text":"What the heck is the instance id? LTIs are loaded in iframes, which means that all cookies are considered third-party and, based on new browser policies, are blocked. This problem manifests itself especially in the context of sessions, since the session identifier, stored in a cookie on the client side by the server, would not persist. Additionally, the package is designed to address various needs that may arise with an LTI, such as a resource in a virtual classroom. If a course has two or more LTI resources, and they are opened independently one after another, the session would be overwritten. A possible solution would be to manage a session and store data according to the open tab, although this modifies the traditional concept of a session and can lead to errors at runtime. Although we have found other details in the process, these two elements were decisive in choosing to create an instance. After various trials and errors, we sought a friendly implementation. The instance includes everything necessary to access what is provided by the LTI, while offering elements to use it as an obfuscated security token (UUID). Instances are generated upon launch; That is, if a person opens the LTI in two different tabs, he will have two different instances. If the person reloads the page while in a browser tab, a new instance will be created. This instance-as-identifier approach is very useful in the context of backend for frontend (BFF), webservices, or other concepts that require an authentication token. To use Laravel as a server-side renderer (SSR) and still use Laravel as usual (possibly with Blade), you can add and retrieve the instance identifier in your forms using the controller. Also note the existence of middlewares and the Blade directive, which will make it easier to pass and obtain the instance ID when working in SSR mode. Retrieve an instance from the handle use App\\Models\\LtiInstance; $instance = LtiInstance::find($instance_id); If you are working with SSR you will have to constantly share your instance identifier between the different forms, you can use the following blade helper to add your instance, this will create an entry with a name defined by the package and then recover the instances with a middleware. @addinstance($instance_id) If you add the instance middleware, it will attempt to retrieve a key called lti1p3-instance-id from the request headers or parameters and initialize the model to include it in your request. inject_lti_instance At this point, you can add the middleware globally and rely on the blade directive to render the identifier of your instance.","title":"Understanding the instance_id"},{"location":"develop/#current-user-roles","text":"Before starting with the functions that the package provides, it is necessary to understand the roles that exist in the vocabulary defined in the LTI 1.3 standard. See role vocabularies If we look at the role tables, these are made up of four scopes: system, institution, membership and person (Although the latter are deprecated, they can still exist). Below, in the point \"A.2.3.1 Context sub-roles\" a grouping of roles is shown without deepening the scope, with a logic of main role and sub-roles, from there the package is based to make some functions available that will allow you to check the role of a user. Eventually the roles of a user can vary depending on the context, while others are general. The package is transparent and on each launch it will store all the roles passed by the LMS and associate them to the context where the LTI is being launched, even if it is a higher context role. Note that there may be a mismatch between the current roles in the LMS and those stored in the LTI. If a user does not launch the LTI, it has no way of knowing the user's current roles. Therefore, if a user does not re-enter the LTI anymore and their roles change, there will be a lag for the roles that are stored. Roles will always be updated for the user in the LTI when it is launched and you can use LTI Advantage Names and Roles Service (NRPS) for update the roles without depend of user access. Behind the scenes, user roles are managed by a different model than user, eventually you will be able to bring in all the roles of a user or work with eloquent as usual. If you are working in a particular context, you will need the roles of that context, so these thoughtful methods for managing LTI roles will help make your life easier. Once you query the roles of a context, the model will keep them inside an array in the respective class instance to avoid multiple queries, since the roles should change (update) only on LTI launch. With this in mind, we describe methods that will help you manipulate roles. The $user variable is an instance of the LtiUser model. The $context variable is a reference to the LtiContext model. $user->isAdmin($context) $user->isContentDeveloper($context) $user->isInstructor($context) $user->isLearner($context) $user->isManager($context) $user->isMentor($context) $user->isOfficer($context) $user->isMember($context) $user->isTestUser($context) By default, the above functions will search for sub-roles in all scopes (system, institution, membership and person), the sub-roles for each \"Main Role\" are defined as an array within the package configuration file, for which, you can modify them from there in case you need it. The user class has a trait that takes care of the roles and has some static properties that will serve to pass as a scope filter to the previous functions. public static $SYSTEM_ROLES = 'http://purl.imsglobal.org/vocab/lis/v2/system/person#'; public static $INSTITUTIONAL_ROLES = 'http://purl.imsglobal.org/vocab/lis/v2/institution/person#'; public static $CONTEX_ROLES = 'http://purl.imsglobal.org/vocab/lis/v2/membership#'; public static $PERSON_ROLES = 'http://purl.imsglobal.org/vocab/lti/system/person#'; Then, you can query for a main role in a particular scope as follows: use App\\Models\\LtiUser; $user->isAdmin($context, LtiUser::$CONTEX_ROLES) user->isContentDeveloper($context, LtiUser::$CONTEX_ROLES) $user->isInstructor($context, LtiUser::$CONTEX_ROLES) $user->isLearner($context, LtiUser::$CONTEX_ROLES) $user->isManager($context, LtiUser::$CONTEX_ROLES) $user->isMentor($context, LtiUser::$CONTEX_ROLES) $user->isOfficer($context, LtiUser::$CONTEX_ROLES) $user->isMember($context, LtiUser::$CONTEX_ROLES) $user->isTestUser($context, LtiUser::$CONTEX_ROLES) Now we will list some functions that may be useful to you. \"Friendly role\": It is the role without the specification prefix Returns the roles in a friendly and unique way, this means that if the role is repeated in different scopes, it will only be shown once. $user->getAllRoles($context) Returns the system roles in a friendly way $user->getSystemRoles($context) Returns institutional roles in a friendly way $user->getInstitutionRoles($context) Returns context roles in a friendly way $user->getContextRoles($context) Return person roles in a friendly way $user->getPersonRoles($context) It receives an array of roles and a context (understand context as the static variables that contain the scope). Returns a boolean in case of having any of the roles, if a context is not passed it will be searched in all contexts. $user->hasSomeRolesOf(Context $context, array $role_list, ?string $role_context=null) Example It will look for the roles in all scopes and returns true if it finds any $user->hasSomeRolesOf($context, ['Administrator', 'Instructor']) It will look for the roles in the context scope and return true if it finds any $user->hasSomeRolesOf($context, ['Administrator', 'Instructor'], LtiUser::$CONTEX_ROLES) It receives a role name and a context (understand context as the static variables that contain the scope). Returns a bolean in case of having the role, if a context is not passed it will be searched in all contexts. $user->hasRole(Context $context, string $role_name , ?string $role_context = null) Example Will look for the role in all scopes $user->hasRole($context, 'Administrator') Will look for the role in the person scope $user->hasRole($context, 'Administrator', LtiUser::$CONTEX_ROLES)","title":"Current user roles"},{"location":"develop/#get-data-from-initial-message","text":"The LTI launch data is contained in a JWT sent as an initial message. This message can be retrieved from the instance managed by the package. The package uses some classes that you can call to work with the initial message and retrieve some more \"raw\" information. use App\\Models\\LtiInstance; use xcesaralejandro\\lti1p3\\Classes\\Content; use xcesaralejandro\\lti1p3\\Classes\\Message; public function onResourceLinkRequest(string $instance_id) : mixed { $instance = LtiInstance::findOrFail($instance_id); $content = Message::decodeJWT($instance->platform, $instance->initial_message); // Get custom vars $some_var_1 = $content->getCustomVar('VAR_DEFINED_IN_THE_LMS'); $some_var_2 = $content->getCustomVarOrFail('VAR_DEFINED_IN_THE_LMS'); // Recovery initial message $raw_message = $content->getRawJwt(); // Redirect to your app logic return (new LaunchController)->appStart($instance_id); } As seen in the previous example, we recover the instance and from the Message class we decode the initial message, then we access some methods that will allow us to obtain personalized variables in a better way and another method that allows us to obtain the initial message with all the information already decoded . Finally we redirect to another point in our application. To learn more methods you can review the public methods in the Content class. Many times you will only need custom variables, since the rest of the values are taken care of by the package in the respective published models.","title":"Get data from initial message"},{"location":"develop/#middlewares","text":"Name Description lti1p3_session Check if the user is logged in as the LTI administrator inject_lti_instance Adds an LtiInstance instance to the request when a key lti1p3-instance-id exists in the headers or parameters of the request.","title":"Middlewares"},{"location":"install/","text":"Install Requeriments Php >= 8.0 Laravel >= 8.0 Set up a domain name You need configure a local domain to develop, since when using JWT, localhost , 127.0.0.1 or your current IP may not work correctly for signing. You can register a local domain name at: Linux: /etc/hosts and Windows: C:\\Windows\\System32\\drivers\\etc\\hosts HTTPS Cert You will need an https certificate to work with LTI, you can use a self-signed one. If you are using docker you can take a look at traefik , otherwise you can look at certbot which will help you obtain a certificate more easily. If not, go for Let's encrypt Installing LTI1P3 Step 1- Add package Use composer to install the dependency with the following command: composer require xcesaralejandro/lti1p3 Step 2 - Publish the provider The package provider will publish controllers, models, migrations, views, and everything you need to get started. You can extend or modify the functionalities later from the published files. php artisan vendor:publish --provider=\"xcesaralejandro\\lti1p3\\Providers\\Lti1p3ServiceProvider\" --force Step 3 - Run migrations php artisan migrate Style problems If you are using some reversible proxy it is possible that the package styles published by the provider will try to load with http instead of https, which produces an error. To fix the problem you can force the https scheme in your app/Providers/AppServiceProvider.php , adding \\URL::forceScheme('https'); in the boot method. Required settings Create admin panel credentials Add the following keys to the Laravel .env file. These will allow you to log in to the administration panel and thereby register the LMS. LTI1P3_ADMIN_USERNAME=example@lti1p3.cl LTI1P3_ADMIN_PASSWORD=lti1p3_admin Update the package configuration file After publishing our provider, we will have a file in config/lti1p3.php . There we must complete the configuration and we can manage the criteria to work with the roles. The required keys within the file lti1p3.php are listed below, the rest should be the default unless you understand that you are changing. Key Description VERIFY_HTTPS_CERTIFICATE If true, will not allow self-signed https certificates. KID An identifier invented by you, this will be used to identify the public key in the Json Web Tokens (JWT) PRIVATE_KEY A private RSA key. This key is used to generate the Json Web Key and encrypt the communication with the LMS. You can generate a new RSA private key of 2048 bit here: https://travistidwell.com/jsencrypt/demo/","title":"Lti1p3 Installation"},{"location":"install/#install","text":"","title":"Install"},{"location":"install/#requeriments","text":"Php >= 8.0 Laravel >= 8.0 Set up a domain name You need configure a local domain to develop, since when using JWT, localhost , 127.0.0.1 or your current IP may not work correctly for signing. You can register a local domain name at: Linux: /etc/hosts and Windows: C:\\Windows\\System32\\drivers\\etc\\hosts HTTPS Cert You will need an https certificate to work with LTI, you can use a self-signed one. If you are using docker you can take a look at traefik , otherwise you can look at certbot which will help you obtain a certificate more easily. If not, go for Let's encrypt","title":"Requeriments"},{"location":"install/#installing-lti1p3","text":"","title":"Installing LTI1P3"},{"location":"install/#step-1-add-package","text":"Use composer to install the dependency with the following command: composer require xcesaralejandro/lti1p3","title":"Step 1- Add package"},{"location":"install/#step-2-publish-the-provider","text":"The package provider will publish controllers, models, migrations, views, and everything you need to get started. You can extend or modify the functionalities later from the published files. php artisan vendor:publish --provider=\"xcesaralejandro\\lti1p3\\Providers\\Lti1p3ServiceProvider\" --force","title":"Step 2 - Publish the provider"},{"location":"install/#step-3-run-migrations","text":"php artisan migrate","title":"Step 3 - Run migrations"},{"location":"install/#style-problems","text":"If you are using some reversible proxy it is possible that the package styles published by the provider will try to load with http instead of https, which produces an error. To fix the problem you can force the https scheme in your app/Providers/AppServiceProvider.php , adding \\URL::forceScheme('https'); in the boot method.","title":"Style problems"},{"location":"install/#required-settings","text":"","title":"Required settings"},{"location":"install/#create-admin-panel-credentials","text":"Add the following keys to the Laravel .env file. These will allow you to log in to the administration panel and thereby register the LMS. LTI1P3_ADMIN_USERNAME=example@lti1p3.cl LTI1P3_ADMIN_PASSWORD=lti1p3_admin","title":"Create admin panel credentials"},{"location":"install/#update-the-package-configuration-file","text":"After publishing our provider, we will have a file in config/lti1p3.php . There we must complete the configuration and we can manage the criteria to work with the roles. The required keys within the file lti1p3.php are listed below, the rest should be the default unless you understand that you are changing. Key Description VERIFY_HTTPS_CERTIFICATE If true, will not allow self-signed https certificates. KID An identifier invented by you, this will be used to identify the public key in the Json Web Tokens (JWT) PRIVATE_KEY A private RSA key. This key is used to generate the Json Web Key and encrypt the communication with the LMS. You can generate a new RSA private key of 2048 bit here: https://travistidwell.com/jsencrypt/demo/","title":"Update the package configuration file"},{"location":"lms_config/","text":"Link with an LMS To link an LMS with an LTI you must make registrations in the LMS and also in your tool. The LMS configuration will vary depending on it and you can review the following documentation: CANVAS and MOODLE . Connection points When configuring the tool in your LMS you will be asked for a URL as a connection point, for all URLs (except JWKS) you must use the following URL replacing your domain. https://[YOUR_APP_LARAVEL_DOMAIN]/lti1p3/connect You will also be prompted for a connection point to the tool's public key, this may appear as JWKS. For this section you must use the following URL https://[YOUR_APP_LARAVEL_DOMAIN]/api/jwks IMPORTANT The connection point to obtain the JWKS must be public, that is, there must be access from your LMS to your connection point. If you are working locally with a domain that is not public to the Internet, the LMS will not be able to obtain the keys. Some LMSs will allow you to enter the manual key instead of a connection URL. You can enter to the URL of your JWKS and from there obtain the key in JSON format to manually add it to the LMS. If you add the key manually instead of using an endpoint, the LMS will have the key and can work locally without having to publicly expose a JWKS URL. Generating a public key requires that you add a private key to the package configuration file located in config/lti1p3.php .","title":"Link with an LMS"},{"location":"lms_config/#link-with-an-lms","text":"To link an LMS with an LTI you must make registrations in the LMS and also in your tool. The LMS configuration will vary depending on it and you can review the following documentation: CANVAS and MOODLE .","title":"Link with an LMS"},{"location":"lms_config/#connection-points","text":"When configuring the tool in your LMS you will be asked for a URL as a connection point, for all URLs (except JWKS) you must use the following URL replacing your domain. https://[YOUR_APP_LARAVEL_DOMAIN]/lti1p3/connect You will also be prompted for a connection point to the tool's public key, this may appear as JWKS. For this section you must use the following URL https://[YOUR_APP_LARAVEL_DOMAIN]/api/jwks IMPORTANT The connection point to obtain the JWKS must be public, that is, there must be access from your LMS to your connection point. If you are working locally with a domain that is not public to the Internet, the LMS will not be able to obtain the keys. Some LMSs will allow you to enter the manual key instead of a connection URL. You can enter to the URL of your JWKS and from there obtain the key in JSON format to manually add it to the LMS. If you add the key manually instead of using an endpoint, the LMS will have the key and can work locally without having to publicly expose a JWKS URL. Generating a public key requires that you add a private key to the package configuration file located in config/lti1p3.php .","title":"Connection points"}]}